<!DOCTYPE html>
<html>
  <head>
		<title>Bowman</title>
		<style>
			body {
				background-color: black;
				margin: 0;
				overflow: hidden;
			}
			#gameCanvas {
				position: absolute;
				z-index: 1;
				background-color: black;
				width: 100%;
				height: 100%;
			}
			#scoreboard {
				position: absolute;
				z-index: 999;
				margin-top: 0px;
				width: 100%;
				text-align: center;
				font-family: Segoe UI, Helvetica, Ubuntu, sans-serif;
				color: white;
			}
			#scores {
				font-size:100%; 
				padding:0; 
				margin:0;
				color: white;
			}
			#title {
				margin-bottom: 10px;
				background-color: white;
				color: black;
			}
		</style>
	</head>
	<body >
		<div id='scoreboard'>
			<h3 id='title'>BOWMAN</h3>
			<h5 style="margin-top: 0px;">Press 1 to use Follow Camera - Press 2 to use MainCamera - Press 3 to inspect all the scene - Press space to ready/unready your arrow</h5>
			<h2 id='scores'>score: 0</h2>
		</div>
		<div id='gameCanvas'>
			<script src="lib/three.min.js"></script>
			<script src="lib/stats.min.js"></script>
			<script src="lib/OBJLoader.js"></script> 
			<script src="lib/dat.gui.min.js"></script>
			<script src="lib/threex.keyboardstate.js"></script> 
			<script type="text/javascript" src="lib/OrbitControls.js"></script>
			<script src="assets/scripts/physics.js"></script>
			<script src="assets/scripts/Utils.js"></script>


			<script>

				//DICHIARAZIONE DI TUTTE LE VARIABILI GLOBALI IN GIOCO

				var scene, mainCamera, arrowCamera, targetCamera, sceneCamera;
				var controls,sceneControls;
				var mouse, keyboard;
				var hitted, arrowLoader, mainActive, sceneActive, readyToFire, released, resetter;
				var y0, x0, x, y;
				var cy0, cx0, cx, cy;
				var ft, rotationGravity, v0, theta, mass, t, t2;
				var floor, floorMaterial, floorGeometry;
				var underGround, underMaterial, underGeometry;
				var sky, skyMaterial, skyGeometry;
				var standardMaterial, bow, loader, arrowContainer, arrowObj, arrowBox, fakeArrow, archer, target, targetBox;
				var arrowObj = null;
				var fakeArrow = null;
				var introOver;
				var count, timeOut;
				var scoredPoints = 0;

				var pivot;

				//INIZIALIZZAZIONE DEL RENDERER, DEGLI STATS E DELLA DAT.GUI

				var renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xffffff, 1);
				var gameCanvas = document.getElementById("gameCanvas");
				gameCanvas.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = "2";
				document.body.appendChild( stats.domElement );

				// DAT GUI CREATION
				var gui = new dat.GUI( { height: 4 * 32 - 1, autoPlace: false} );
				gui.domElement.style.position = 'absolute';
				gui.domElement.style.bottom = '0px';
				gui.domElement.style.right = '0px';
				gui.domElement.style.zIndex = "2";

				var effectController = { tension: 0.2, lb: 50, target: 100 };

				gui.add(effectController, 'tension', 0.2, 0.6).name('Allungo').step(0.1);
				gui.add(effectController, 'lb', 20, 70).name('Libraggio arco').step(5);
				gui.add(effectController, 'target', 10, 500).step(10).name('Target');

				document.body.appendChild(gui.domElement);
				//FUNZIONE INIT CHE DA IL VIA ALLA CREAZIONE DI UNA NUOVA SCENA

				function init(){

					scene = new THREE.Scene();
					mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					arrowCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
					targetCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
					targetCamera.position.x = 1;
					targetCamera.position.y = 3;
					targetCamera.position.z = 3;
				   sceneCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);


					controls = new THREE.OrbitControls( mainCamera, renderer.domElement );
					controls.enabled = false;
					sceneControls = new THREE.OrbitControls( sceneCamera, renderer.domElement );

					mouse = new THREE.Vector2();
					keyboard = new THREEx.KeyboardState();

					hitted = false;					//variabile booleana che controlla se il targer viene centrato
					mainActive = true;				//telecamera principale abilitata/disabilitata
					readyToFire = false;			//freccia pronta ad essere scoccata
					arrowLoader = true;				//variabile che gestisce il calcolo della posizione iniziale della freccia (da fare una sola volta)
					released = false;				//freccia scoccata
					introOver = false;				// animazione introduttiva da eseguire
					resetter= false;
					sceneActive = false;

					//INIZIALIZZAZIONE DELLE VARIABILI USATE NEI CALCOLI DELLA FISICA DEL PROIETTILE

					theta = 0; 						//theta Ã¨ in gradi
					mass = 0.025;					//massa della freccia in kg
					t = 0;							//tempo
					t2 = 0;							//tempo (arrowCamera)

					count = 0;						//contatore ausiliario
					timeOut = 0;
					
					mainCamera.position.set(0, 0, 5);
					arrowCamera.position.set(-2, 1.3, 0);
					scene.add(arrowCamera);

					// FLOOR
					floorMaterial = new THREE.MeshBasicMaterial( { color: 0x028D27, side: THREE.DoubleSide } );
					floorGeometry = new THREE.CircleGeometry(2000, 200);
					floor = new THREE.Mesh(floorGeometry, floorMaterial);
					floor.rotation.x = Math.PI / 2;
					scene.add(floor);	

					// UNDERGROUND
					underMaterial = new THREE.MeshBasicMaterial( {color: 0x493000,  side: THREE.BackSide} );
					underGeometry = new THREE.SphereGeometry( 900, 200, 200, 0, Math.PI);
					underGround = new THREE.Mesh(underGeometry, underMaterial);
					underGround.rotation.x = Math.PI / 2;
					scene.add(underGround);

					// SKY
					skyMaterial = new THREE.MeshBasicMaterial( {color: 0x77FFFC, side: THREE.BackSide } );
					skyGeometry = new THREE.SphereGeometry( 900, 200, 200, 0, Math.PI);
					sky = new THREE.Mesh(skyGeometry, skyMaterial);
					sky.rotation.x = -Math.PI / 2;
					scene.add(sky);

					arrowObj = null;
					fakeArrow = null;

					document.getElementById("scores").innerHTML = "score: " + scoredPoints.toString(); //+ scoredPoints

					//LOADING BOW MESH
					standardMaterial = new THREE.MeshBasicMaterial();
					bow = new THREE.Object3D();
					loader = new THREE.OBJLoader();
					loader.load( 'assets/models/Bow.obj', function(object) { 
						object.material = standardMaterial;
						bow.add(object);
						} );
					bow.position.set(0,1.3,0);
					scene.add(bow);

					//CREATING ARROW CONTAINER
					arrowContainer = new THREE.Object3D();
					scene.add(arrowContainer);
					arrowContainer.position.set(0, 1.3, 0);
					arrowContainer.add(mainCamera);

					//CREATING ARCHER CONTAINER
					archer = new THREE.Object3D();
							archer.add(bow);
							archer.add(arrowContainer);
							scene.add(archer);

					//ARROW COLLISION BOX
					arrowBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );
					
					//LOADING ARROW MESH
					loader = new THREE.OBJLoader( );
					loader.load( 'assets/models/Arrow.obj', function ( object ) {
						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
						    child.material = new THREE.MeshBasicMaterial({color: 0x00ff00});;
						    }
						});
						arrowObj = object;
						arrowContainer.add(arrowObj);
						arrowObj.visible = false;
						fakeArrow = arrowObj.clone();
						fakeArrow.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
						    child.material = new THREE.MeshBasicMaterial({color: 0xff0000});;
						    }
						});
						fakeArrow.visible = true;
						bow.add(fakeArrow);
					
						arrowCamera.lookAt(arrowContainer.position);
					} );

					//LOADING TARGET MESH
					target = new THREE.Object3D();
					loader.load('assets/models/Target.obj', function (object ) {

						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
						    child.material = new THREE.MeshBasicMaterial({color: 0x0000ff});
						    }
						});

						target.add(object);
						});

					target.rotation.y = 90 * Math.PI / 180;	
					scene.add(target);

					// TARGET COLLISION BOX
					targetBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );

					pivot = new THREE.Object3D();
					scene.add(pivot);
					pivot.add(sceneCamera);

					sceneCamera.position.y = 100;

				}


				function onMouseMove( event ) {
					
					if(!released && mainActive){
					    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	

					    theta = getAngle(0, 0, mouse.x, mouse.y);

					    if(mouse.y <0){
							theta = -theta;
					    }

					    if(arrowObj && bow){
							arrowObj.rotation.z = theta * 0.0174533;
							bow.rotation.z = theta * 0.0174533
					    }

					    v0 = computeVelInit(mass, effectController.lb, effectController.tension);
					    ft = flightTime(v0, theta);
					    rotationGravity = 2*theta*0.0174533 * 0.016666666667 / ft;
					}

				}	
				
				function onDocumentMouseDown(event){
				    if (readyToFire) {
					released = true;
					controls.enabled = true;
				    }
				}
					

				window.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'mousedown', onDocumentMouseDown, false );


				function render(){
					requestAnimationFrame(render);
					
					stats.update();

					// RENDERIZZA ANIMAZIONE INIZIALE
					if (!introOver) {
						target.position.x = effectController.target;
						targetCamera.lookAt(arrowContainer.position);

						if(targetCamera.position.x <= target.position.x + 50)
							targetCamera.position.x += 1;
						else
							introOver = true;

						renderer.render(scene, targetCamera);

					} 
					// RENDERIZZA IL GIOCO
					else {

						sceneControls.update();

						if(!readyToFire){
							target.position.x = effectController.target;  // target posizionato dall'utente
							pivot.position.x = effectController.target / 2;
						}

						var percenTns = effectController.tension * 100 / 0.6;
						if(fakeArrow){
							fakeArrow.position.x = -( percenTns / 100);
						}
						

						if(keyboard.pressed("1") && released){
							mainActive = false;
							sceneActive = false;
						}
						if(keyboard.pressed("2")){
							mainActive = true;
							sceneActive = false;
						}
						if(keyboard.pressed("3")){
							mainActive = false;
							sceneActive = true;
						}

						if(keyboard.pressed("space") && timeOut == 0){
							timeOut = 30;
							readyToFire = !readyToFire; 
							fakeArrow.traverse(function (child) {
							   if (child instanceof THREE.Mesh) {
							     	child.material  =  readyToFire ? new THREE.MeshBasicMaterial({color: 0x00ff00}) : new THREE.MeshBasicMaterial({color: 0xff0000});
							   }
							}) 
						}

						if(keyboard.pressed("E") && resetter){
							init();
						}

					
						if(mainActive){
							renderer.render(scene, mainCamera);
						} else {
							sceneActive ? renderer.render(scene, sceneCamera) : renderer.render(scene, arrowCamera);
						}
						
						//tempo = 1/60 secondi = 0.016666666667
						if(arrowObj && arrowLoader){
							y0=arrowContainer.position.y;
							x0=arrowContainer.position.x;
							cy0=arrowCamera.position.y;
							cx0=arrowCamera.position.x;

							y = y0;
							x = x0;
							cy = cy0;
							cx = cx0;
							arrowLoader = false;		
						}

						if(arrowObj && released){

							controls.update();
							arrowObj.visible = true;
							fakeArrow.visible = false;

						    if( y>=0 && !hitted){

								arrowBox.setFromObject(arrowObj);
								targetBox.setFromObject(target);

								if(!arrowBox.isIntersectionBox(targetBox)){

								    x = computeXShot(x0, theta, v0, t);
								    y = computeYShot(y0, theta, v0, t);
								    t+=0.01667;

								    arrowObj.rotation.z -= rotationGravity;
								    arrowContainer.position.set(x, y, arrowContainer.position.z);

									if(count >= 60){
										cx = computeXShot(cx0, theta, v0, t2);
										cy = computeYShot(cy0, theta, v0, t2);
										t2+=0.01667;

										arrowCamera.position.set(cx, cy, arrowContainer.position.z);
										sky.position.x = arrowContainer.position.x;
										underGround.position.x = arrowContainer.position.x;
									    }

									   if(y<=0){
									   	document.getElementById("scores").innerHTML += "<br>Press E to shoot more";
									   	resetter = true;
									   }

								} else {

									x = computeXShot(x0, theta, v0, t);
								   y = computeYShot(y0, theta, v0, t);
								   t += 0.01667; 

									arrowContainer.position.set(x, y, arrowContainer.position.z);
									hitted = true;

									// Calcolo punteggio
									/*
									if (y < 1.16 && y > 0.99)
										scoredPoints = 100;
									else if (y < 1.25 && y > 0.90)
										scoredPoints = 70;
									else if (y < 1.50 && y > 0.60)
										scoredPoints = 30;
									else if (y <= 1.9 && y >= 0.3)
										scoredPoints = 10;
									*/
									
									if (y <= 1.3 && y >= 1.0)
										scoredPoints += 100;
									else
										scoredPoints += Math.floor(100 - 70 * Math.abs(1.15 - y));
									

									document.getElementById("scores").innerHTML = "score: " + scoredPoints.toString(); //+ scoredPoints

									document.getElementById("scores").innerHTML += "<br>Press E to shoot more";
									resetter = true;
								}
							}

						}
						count++;
						if (timeOut > 0)
							timeOut--;
					}
				}

				init();
				render();
			</script>
		</div>
	</body>
</html>