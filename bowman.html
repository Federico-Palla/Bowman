<!DOCTYPE html>
<html>
  <head>
		<title>Bowman</title>
		<style>
			body {
				background-color: black;
				margin: 0;
				overflow: hidden;
			}
			#gameCanvas {
				position: absolute;
				z-index: 1;
				background-color: black;
				width: 100%;
				height: 100%;
			}
			#scoreboard {
				position: absolute;
				z-index: 999;
				margin-top: 0px;
				width: 100%;
				text-align: center;
				font-family: Segoe UI, Helvetica, Ubuntu, sans-serif;
				color: white;
			}
			#scores {
				font-size:100%; 
				padding:0; 
				margin:0;
				color: white;
			}
			#title {
				margin-bottom: 10px;
				background-color: white;
				color: black;
			}
		</style>
	</head>
	<body >
		<div id='scoreboard'>
			<h3 id='title'>BOWMAN</h3>
			<h5 style="margin-top: 0px;">Press 1 to use Follow Camera - Press 2 to use MainCamera - Press 3 to inspect the whole scene - Press space to ready/unready your arrow</h5>
			<h2 id='scores'>score: 0</h2>
		</div>
		<div id='gameCanvas'>
			<script src="lib/three.min.js"></script>
			<script src="lib/stats.min.js"></script>
			<script src="lib/OBJLoader.js"></script> 
			<script src="lib/dat.gui.min.js"></script>
			<script src="lib/threex.keyboardstate.js"></script> 
			<script type="text/javascript" src="lib/OrbitControls.js"></script>
			<script src="assets/scripts/physics.js"></script>
			<script src="assets/scripts/Utils.js"></script>

			<script src="assets/shaders/lambertianShader.js"></script>
			<script src="assets/shaders/microFacetShader.js"></script>
			<script src="assets/shaders/groundShader.js"></script>
			<script src="assets/shaders/killCamShader.js"></script>

			<script src="lib/Animation.js"></script>
			<script src="lib/AnimationHandler.js"></script>
			<script src="lib/KeyFrameAnimation.js"></script>
			<script src="lib/ColladaLoader.js"></script>
			<script src="lib/EffectComposer.js"></script>
			<script src="lib/CopyShader.js"></script>
			<script src="lib/ShaderPass.js"></script>
			<script src="lib/RenderPass.js"></script>
			<script src="lib/MaskPass.js"></script>

			<script src="lib/Tween.js"></script>

			<script>

				//DICHIARAZIONE DI TUTTE LE VARIABILI GLOBALI IN GIOCO
				var scene, mainCamera, arrowCamera, targetCamera, sceneCamera;
				var controls,sceneControls;
				var mouse = new THREE.Vector2();
				var keyboard = new THREEx.KeyboardState();
				var hitted, arrowLoader, mainActive, sceneActive, readyToFire, released, resetter;
				var y0, x0, x, y;
				var cy0, cx0, cx, cy;
				var ft, rotationGravity, v0, theta, mass, t, t2;
				var floor, floorMaterial, floorGeometry;
				var underGround, underMaterial, underGeometry;
				var pivot;

				// Arrows related
				var standardMaterial, bow, loader, arrowContainer, arrowObj, arrowBox, fakeArrow, archer, target, targetBox;
				var arrArrow;
				var arrowObj = null;
				var fakeArrow = null;
				var introOver;
				var count, timeOut;
				var scoredPoints = 0;
				var arrowCount = 3;
				var empty = true;
				var releaseCam = false;

				// Uniforms
				var uniforms_normal, uniforms_brick, prat_uniforms, arrow_uniforms, bow_uniforms, uniforms_cart;
				
				// Monster related
				var monster_alive, monster_death, monster_attack, deathAnimation, attackAnimation;
				var monst_diff, monst_norm;
				var trigger = true;
				var enableWriting = true;
				var missed = false;

				// Sound related
				var listener, playSound, killSound, monsterKillSound, failSound;
				var showFatality, fatal_mesh, tween, tween_pos, tween_tar, tweenActive;

				// Quaternions
				var statue1, statue2, statue3;
				var statueCounter = 0;
				var q, q1, q2;
				var tempo = 0.0;

				// Column related
				var arrStat = [];						// array per le statue		
				var preload = true;
				var loader = new THREE.OBJLoader( );

				// Kill-cam related
				var clock = new THREE.Clock(true);
				var composer, killCam;
				var color = Math.PI/2;

				//LUCI
				var lightPower = new THREE.Vector3(25.0, 25.0, 25.0);
				var lightPowerRed = new THREE.Vector3(2000.0, 2000.0, 2000.0);
				var lightPowerGreen = new THREE.Vector3(2000.0, 2000.0, 2000.0);
				var pointLightPower = new THREE.Vector3(700.0, 700.0, 700.0);
				var redLight = new THREE.Vector3(1.0, 0.0, 0.0);
				var greenLight = new THREE.Vector3(0.0, 1.0, 0.0);
				var NO_POWER = new THREE.Vector3(0.0, 0.0, 0.0);
				var light2, light3;

				var ambiente = new THREE.Vector3( 0.3,0.3,0.3 );	//termine ambiente
				
				//INIZIALIZZAZIONE DEL RENDERER, DEGLI STATS E DELLA DAT.GUI
				var renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xffffff, 1);
				var gameCanvas = document.getElementById("gameCanvas");
				gameCanvas.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.bottom = '0px';
				stats.domElement.style.zIndex = "2";
				document.body.appendChild( stats.domElement );

				// DAT GUI CREATION
				var gui = new dat.GUI( { height: 4 * 32 - 1, autoPlace: false} );
				gui.domElement.style.position = 'absolute';
				gui.domElement.style.bottom = '0px';
				gui.domElement.style.right = '0px';
				gui.domElement.style.zIndex = "2";

				var effectController = { tension: 0.2, lb: 50, target: 100 };

				gui.add(effectController, 'tension', 0.2, 0.6).name('Allungo').step(0.1);
				gui.add(effectController, 'lb', 20, 70).name('Libraggio arco').step(5);
				gui.add(effectController, 'target', 20, 100).step(10).name('Distanza Target').listen();
				document.body.appendChild(gui.domElement);
				
				// INIZIALIZZAZIONE DELLA SCENA
				function init(){

					loadNPC();

					scene = new THREE.Scene();
					mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
					arrowCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 15000);
					targetCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 15000);
					mobCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 15000);
					targetCamera.position.x = 1;
					targetCamera.position.y = 3;
					targetCamera.position.z = 3;
				   	sceneCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 15000);

					controls = new THREE.OrbitControls( mainCamera, renderer.domElement );
					controls.enabled = false;
					sceneControls = new THREE.OrbitControls( sceneCamera, renderer.domElement );
					
					//INIZIALIZZAZIONE DELLE VARIABILI				
					
					readyToFire = false;			// freccia pronta 
					released = false;				// freccia scoccata
					arrowLoader = true;				//variabile che gestisce il calcolo della posizione iniziale della freccia (da fare una sola volta)				
					
					hitted = false;					// mostro colpito
					slained = false;				// protagonista morto
					trigger = true;					// animazioni mostro
					enableWriting = true;			// screen info
					missed = false;					//bersaglio mancato

					//INIZIALIZZAZIONE DELLE VARIABILI USATE NEI CALCOLI DELLA FISICA DEL PROIETTILE
					theta = 0; 						//theta è in gradi
					mass = 0.025;					//massa della freccia in kg
					t = 0;							//tempo
					t2 = 0;							//tempo (arrowCamera)

					tempo = 0.0;					//tempo (quaternion)

					//contatori ausiliari

					count = 0;						
					timeOut = 0;					
					
					// Gestione telecamere
					introOver = false;				// animazione introduttiva
					mainActive = true;				// camera principale 
					sceneActive = false;			// camera della scena
					resetter = false;				// possibilità di resettare

					mainCamera.position.set(0, 0, 6);
					arrowCamera.position.set(-2, 1.3, 0);
					scene.add(arrowCamera);

					// LUCI
					// Ambient light per la mesh del mostro
					var ambLight = new THREE.AmbientLight( 0x404040 ); // soft white light
					scene.add( ambLight );

					//LUCI DEFINITE MANUALMENTE

					//Directional Light
					var light = new THREE.Mesh( new THREE.SphereGeometry( 0.2, 16, 16), new THREE.MeshBasicMaterial ({color: 0xffff00, wireframe:true}));
					light.position.set( 0.0, 500.0, 0.0 );
					scene.add( light );

					//Point Light (rossa)
					light2 = new THREE.Mesh( new THREE.SphereGeometry( 0.2, 16, 16), new THREE.MeshBasicMaterial ({color: 0xff0000, wireframe:true}));
					light2.position.set( -4.0, 4.06, -4.0 );
					scene.add( light2 );
					
					//Point Light (verde)
					light3 = new THREE.Mesh( new THREE.SphereGeometry( 0.2, 16, 16), new THREE.MeshBasicMaterial ({color: 0x00ff00, wireframe:true}));
					light3.position.set( -4.0, 4.06, -4.0 );
					//inizialmente la luce verde non è visibile
					light3.visible = false;						
					scene.add( light3 );

					//Spot Light
					var light4 = new THREE.Mesh( new THREE.SphereGeometry( 0.2, 16, 16), new THREE.MeshBasicMaterial ({color: 0xffffff, wireframe:true}));
					light4.position.set( 0.0, 5.0, 1.0 );
					scene.add( light4 );


					// Audio scena
					listener = new THREE.AudioListener();
 					mainCamera.add( listener );
 					playSound = false;

 					//Gestione Fatality
 					showFatality = false;
 					tweenActive = false; 			// tween "Fatality"


 					// Post processing
					composer = new THREE.EffectComposer( renderer );
					composer.addPass( new THREE.RenderPass( scene, mainCamera ) );

					killCam = new THREE.ShaderPass( killShader );
					composer.addPass( killCam );

					var effect = new THREE.ShaderPass( THREE.CopyShader);
					effect.renderToScreen = true;
					composer.addPass( effect );

					// GENERAZIONE DELLA SCENA

					//PRATO (displacement)

					var diffuse_grass = THREE.ImageUtils.loadTexture( "assets/textures/grass_diffuse.png" );
					var normal_grass = THREE.ImageUtils.loadTexture( "assets/textures/grass_norm.png" );
					var displacement_grass = THREE.ImageUtils.loadTexture( "assets/textures/grass_displ.jpg" );
					var displacementScale = 0.5;

					diffuse_grass.minFilter = THREE.LinearMipMapLinearFilter; 
					diffuse_grass.anisotropy = renderer.getMaxAnisotropy();
					normal_grass.minFilter = THREE.LinearMipMapLinearFilter; 
					normal_grass.anisotropy = renderer.getMaxAnisotropy();

					var ground_geometry = new THREE.PlaneBufferGeometry(4, 4, 96, 96);

					uniforms_normal = {
						diffuseMap: {type: "t", value: diffuse_grass},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) },
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						ambient:	{ type: "v3", value: ambiente },
						normalMap: {type: "t", value: normal_grass },
						normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
						displacementMap: {type: "v2", value: displacement_grass},
						displacementScale: {type: "f", value: displacementScale},
						times: {type: "f", value: 1.0},
						lightColor2: {type: "v3", value: redLight},
						lightColor3: {type: "v3", value: greenLight},
					};


					var grass_material = new THREE.ShaderMaterial({ uniforms: uniforms_normal, vertexShader: groundShader.vertexShader, fragmentShader: groundShader.fragmentShader });

					var grassCube = new THREE.Mesh( ground_geometry, grass_material );
					grassCube.rotation.x = -90 * Math.PI / 180;
					scene.add( grassCube );

					for(var i = 0; i < 28; i++){
						var cubo = grassCube.clone();
						cubo.position.x = 3.99 * i;
						scene.add(cubo);
					}

					//PORZIONE PAVIMENTATA DELLA SCENA (displacement)

					var diffuse_floor = THREE.ImageUtils.loadTexture( "assets/textures/floor_diffuse.jpg" );
					var normal_floor = THREE.ImageUtils.loadTexture( "assets/textures/floor_normal.jpg" );
					var displacement_floor = THREE.ImageUtils.loadTexture( "assets/textures/floor_displ.jpg" );

					uniforms_brick = {
						diffuseMap: {type: "t", value: diffuse_floor},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						normalMap: {type: "t", value: normal_floor },
						normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
						displacementMap: {type: "v2", value: displacement_floor},
						displacementScale: {type: "f", value: 0.1},
						times: {type: "f", value: 1.0},
						ambient:	{ type: "v3", value: ambiente },
						lightColor2: {type: "v3", value: redLight},
						lightColor3: {type: "v3", value: greenLight},
					};

					var floor_material = new THREE.ShaderMaterial({ uniforms: uniforms_brick, vertexShader: groundShader.vertexShader, fragmentShader: groundShader.fragmentShader });

					var floor = new THREE.Mesh( ground_geometry, floor_material );
					floor.rotation.x = -90 * Math.PI / 180;
					floor.position.x = -4.0;
					scene.add( floor );
					var floor2 = floor.clone();
					floor2.position.z = -4.0;
					var floor3 = floor.clone();
					floor3.position.z = 4.0;
					scene.add( floor2 );
					scene.add( floor3 );

					var floor4 = floor2.clone();
					floor4.position.x = 0.0;
					var floor5 = floor3.clone();
					floor5.position.x = 0.0;
					scene.add( floor4 );
					scene.add( floor5 );

					var floor6 = floor2.clone();
					floor6.position.x = 4.0;
					var floor7 = floor3.clone();
					floor7.position.x = 4.0;
					scene.add( floor6 );
					scene.add( floor7 );

					var floor8 = floor2.clone();
					floor8.position.x = 8.0;
					var floor9 = floor3.clone();
					floor9.position.x = 8.0;
					scene.add( floor8 );
					scene.add( floor9 );

					//PRATO (no displacement)

					var prato_geometry = new THREE.PlaneBufferGeometry(500, 500);

					prat_uniforms = {
						diffuseMap: {type: "t", value: diffuse_grass},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						normalMap: {type: "t", value: normal_grass },
						normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
						ambient:	{ type: "v3", value: ambiente },
						lightColor2: {type: "v3", value: redLight},
						times: {type: "f", value: 120.0},
						lightColor3: {type: "v3", value: greenLight},
					}

					prat_uniforms.diffuseMap.value.wrapS = prat_uniforms.diffuseMap.value.wrapT = THREE.RepeatWrapping;
					prat_uniforms.normalMap.value.wrapS = prat_uniforms.normalMap.value.wrapT = THREE.RepeatWrapping;

					var prato_mat = new THREE.ShaderMaterial({uniforms: prat_uniforms, vertexShader: groundShader.vertexShader, fragmentShader: groundShader.fragmentShader});
					var prato = new THREE.Mesh(prato_geometry, prato_mat);
					prato.rotation.x = -90 * Math.PI / 180;
					scene.add(prato);

					// UNDERGROUND
					underMaterial = new THREE.MeshBasicMaterial( {color: 0x493000,  side: THREE.BackSide} );
					underGeometry = new THREE.SphereGeometry( 250, 200, 200, 0, Math.PI);
					underGround = new THREE.Mesh(underGeometry, underMaterial);
					underGround.rotation.x = Math.PI / 2;
					underGround.position.y = -0.5;
					scene.add(underGround);

					// ENVIRONMENT MAP
					var path = "assets/textures/TropicalSunnyDay/";
					var format = ".png";

					var urls = [
							path + "px" + format, path + "nx" + format,
							path + "py" + format, path + "ny" + format,
							path + "pz" + format, path + "nz" + format
						];

					var textureCube = new THREE.ImageUtils.loadTextureCube( urls );

					var shader = THREE.ShaderLib[ "cube" ];
					shader.uniforms[ "tCube" ].value = textureCube;

					var materiale = new THREE.ShaderMaterial( {

						fragmentShader: shader.fragmentShader,
						vertexShader: shader.vertexShader,
						uniforms: shader.uniforms,
						side: THREE.BackSide

					} );

					mesh = new THREE.Mesh( new THREE.BoxGeometry( 10000, 10000, 10000 ), materiale );
					scene.add( mesh );

					//Inizializzazione frecce
					arrowObj = null;
					fakeArrow = null;

					//Visualizzazione punteggio
					document.getElementById("scores").innerHTML = "score: " + scoredPoints.toString();

					//LOADING BOW MESH
					var diff_bow = THREE.ImageUtils.loadTexture("assets/textures/bow_diff.png");
					var norm_bow = THREE.ImageUtils.loadTexture("assets/textures/bow_norm.png");

					bow_uniforms = {
						diffuseMap:	{ type: "t", value: diff_bow},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						normalMap: { type: "t", value: norm_bow },
						normalScale: { type: "v2", value: new THREE.Vector2(1,1) },
						ambient:	{ type: "v3", value: ambiente },
						lightColor2: {type: "v3", value: redLight},
						lightColor3: {type: "v3", value: greenLight},
					};

					var bow_mat = generateMaterialL( bow_uniforms, diff_bow, norm_bow);

					bow = new THREE.Object3D();
					loader = new THREE.OBJLoader();
					loader.load( 'assets/models/Bow.obj', function(object) { 

						object.traverse(function (child) {

						    if (child instanceof THREE.Mesh) {
						    child.material = bow_mat;
						    child.rotation.y = 90 * Math.PI/180;
						    }

						});

						bow.add(object);
						bow.visible = true;

					} );

					bow.position.set(0,1.3,0);
					scene.add(bow);

					//CREATING ARROW CONTAINER
					arrowContainer = new THREE.Object3D();
					scene.add(arrowContainer);
					arrowContainer.position.set(0, 1.3, 0);
					arrowContainer.add(mainCamera);

					//CREATING ARCHER CONTAINER
					archer = new THREE.Object3D();
					archer.add(bow);
					archer.add(arrowContainer);
					scene.add(archer);

					//ARROW COLLISION BOX
					arrowBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );
					
					//LOADING ARROW MESH
					var arrow_diffuse = THREE.ImageUtils.loadTexture( "assets/textures/diffuse.png");
					var arrow_specular = THREE.ImageUtils.loadTexture( "assets/textures/specular.png" );
					var arrow_normal = THREE.ImageUtils.loadTexture( "assets/textures/normal.png" );

					arrow_uniforms = {
						specularMap: { type: "t", value: arrow_specular},
						diffuseMap:	{ type: "t", value: arrow_diffuse},
						ambient:	{ type: "v3", value: ambiente },
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						alpha: {type: "f", value: 0.1},
						s: {type: "f", value: 0.3},
						normalMap: { type: "t", value: arrow_normal },
						normalScale: { type: "v2", value: new THREE.Vector2(1,1) },
						lightColor2: {type: "v3", value: redLight},
						lightColor3: {type: "v3", value: greenLight},
					};

					var arrow_material = generateMaterialMF( arrow_uniforms, arrow_diffuse, arrow_specular, arrow_normal);

					loader = new THREE.OBJLoader();
					loader.load( 'assets/models/Arrow.obj', function ( object ) {

						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
						    child.material = arrow_material;
						    }
						});

						arrowObj = object;
						arrowContainer.add(arrowObj);
						arrowObj.visible = false;

						fakeArrow = arrowObj.clone();
						fakeArrow.traverse(function (child) {

						    if (child instanceof THREE.Mesh) {
						    child.material = arrow_material;
						    }

						});

						fakeArrow.visible = true;
						bow.add(fakeArrow);
					
						arrowCamera.lookAt(arrowContainer.position);
					} );

					// TARGET COLLISION BOX
					targetBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );

					//LOADING CART MESH
					var cart_diff = THREE.ImageUtils.loadTexture( "assets/textures/cart_diff.png" );
					var cart_norm = THREE.ImageUtils.loadTexture( "assets/textures/cart_norm.png" );
					var cart_spec = THREE.ImageUtils.loadTexture( "assets/textures/cart_spec.png" );
					
					uniforms_cart = {
						diffuseMap: {type: "t", value: cart_diff},
						normalMap: {type: "t", value: cart_norm },
						specularMap: { type: "t", value: cart_spec},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:	{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						alpha: {type: "f", value: 0.95},
						s: {type: "f", value: 0.05},
						normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
						ambient:	{ type: "v3", value: ambiente },
					};

					var cart_mat = generateMaterialMF(uniforms_cart, cart_diff, cart_spec, cart_norm);
					
					loader.load( 'assets/models/Cart.obj', function ( object ) {

						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
							    child.material = cart_mat;
						    }
						});
						object.scale.set(0.02, 0.02, 0.02);
						object.position.set(-4.0, -0.5, 2.0);
						object.rotation.y = 90 * Math.PI / 180;
						scene.add(object);

					} );

					// LOADING STREETLAMP 
					var lamp_diffuse = THREE.ImageUtils.loadTexture( "assets/textures/lamp_diff.jpg");
					var lamp_specular = THREE.ImageUtils.loadTexture( "assets/textures/lamp_spec.png" );
					var lamp_normal = THREE.ImageUtils.loadTexture( "assets/textures/lamp_norm.png" );

					lamp_uniforms = {
						specularMap: 	{ type: "t", value: lamp_specular}, 
						diffuseMap:		{ type: "t", value: lamp_diffuse},
						ambient:		{ type: "v3", value: ambiente },
						m: 				{type: "f", value: 0},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:		{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						alpha: 			{type: "f", value: 0.1},
						s: 				{type: "f", value: 0.3},
						normalMap: 		{ type: "t", value: lamp_normal },
						normalScale: 	{ type: "v2", value: new THREE.Vector2(1,1) },
						lightColor2: 	{type: "v3", value: redLight},
						lightColor3: 	{type: "v3", value: greenLight},
					};

					var lamp_material = generateMaterialMF( lamp_uniforms, lamp_diffuse, lamp_specular, lamp_normal);

					loader.load( 'assets/models/Lamp.obj', function ( object ) {

						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
							    child.material = lamp_material;
						    }
						});

						var scale = 0.3;
						object.scale.set(scale, scale, scale);
						object.position.set(-4.0, -0.5, -4.0);
						object.rotation.y = 90 * Math.PI / 180;
						scene.add(object);

					} );

					// LOADING TROPHY (Column + unanimated monster mesh)
					// Indica la quantità di mostri uccisi

					monst_diff = THREE.ImageUtils.loadTexture("assets/textures/monster.jpg");
					monst_norm = THREE.ImageUtils.loadTexture("assets/textures/monster_norm.png");


					monst_uniforms = {
						diffuseMap:		{ type: "t", value: monst_diff},
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:		{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						normalMap: 		{ type: "t", value: null },
						normalScale: 	{ type: "v2", value: new THREE.Vector2(1,1) },
						ambient:	{ type: "v3", value: ambiente },						
						lightColor2: {type: "v3", value: redLight},
						lightColor3: {type: "v3", value: greenLight},
					};

					//Setup dei Quaternion

					q = new THREE.Quaternion();
					q.setFromAxisAngle((new THREE.Vector3(1,2,4)).normalize(),Math.PI / 4);					

					q1 = new THREE.Quaternion();
					q1.setFromAxisAngle((new THREE.Vector3(0,1,0)).normalize(),Math.PI / 2);
					
					q2 = new THREE.Quaternion();
					q2.setFromAxisAngle((new THREE.Vector3(0,1,0)).normalize(),Math.PI);

					// COLONNA
					var column_diff = THREE.ImageUtils.loadTexture("assets/textures/column_diff.png");
					var column_spec = THREE.ImageUtils.loadTexture("assets/textures/column_spec.png");
					var column_norm = THREE.ImageUtils.loadTexture("assets/textures/column_norm.png");

					column_uniforms = {
						specularMap: 	{ type: "t", value: column_spec}, 
						diffuseMap:		{ type: "t", value: column_diff},
						ambient:		{ type: "v3", value: ambiente },
						LightPosition:	{ type: "v3", value: new THREE.Vector3(light.position.x, light.position.y, light.position.z) },
						LightPosition2:	{ type: "v3", value: new THREE.Vector3(light2.position.x, light2.position.y, light2.position.z) },
						LightPosition3:	{ type: "v3", value: new THREE.Vector3(light3.position.x, light3.position.y, light3.position.z) }, 
						LightPosition4:	{ type: "v3", value: new THREE.Vector3(light4.position.x, light4.position.y, light4.position.z) }, 
						lightPower4:	{ type: "v3", value: pointLightPower },
						lightPower:		{ type: "v3", value: lightPower },
						lightPower2:	{ type: "v3", value: lightPowerRed },
						lightPower3:	{ type: "v3", value: NO_POWER },
						alpha: 			{type: "f", value: 0.1},
						s: 				{type: "f", value: 0.3},
						normalMap: 		{ type: "t", value: column_norm },
						normalScale: 	{ type: "v2", value: new THREE.Vector2(1,1) },
						lightColor2: 	{type: "v3", value: redLight},
						lightColor3: 	{type: "v3", value: greenLight},
					};

					loadColumns(loader, column_uniforms, column_diff, column_norm);

					//MONSTER MESH

					var monst_material = generateMaterialL( monst_uniforms, monst_diff, monst_norm);

					loader.load( 'assets/models/Monster.obj', function ( object ) {
						object.traverse(function (child) {
						    if (child instanceof THREE.Mesh) {
							    child.material = monst_material;
						    }
						});
							var scale = 0.005;
							statue1 = object;
							statue1.scale.set(scale, scale, scale);
					} );

					// SOUNDS
					killSound = new THREE.PositionalAudio( listener );
					killSound.load( 'assets/sounds/archer_scream.wav' );
					killSound.setRefDistance( 15 );
	
					monsterKillSound = new THREE.PositionalAudio( listener );
					monsterKillSound.load( 'assets/sounds/monster_scream.wav' );
					monsterKillSound.setRefDistance( 18 );

					failSound = new THREE.PositionalAudio( listener );
					failSound.load( 'assets/sounds/fail_sound.wav' );
					failSound.setRefDistance( 18 );

					//Pivot: utile per osservare l'intera scena mediante la scene camera
					pivot = new THREE.Object3D();
					scene.add(pivot);
					pivot.add(sceneCamera);

					sceneCamera.position.y = 100;

				}

				// Al movimento del mouse l'arco ruota, fornendo l'angolo per il calcolo della traiettoria del proiettile
				function onMouseMove( event ) {
					
					if(!released && mainActive){
					    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	

					    theta = getAngle(0, 0, mouse.x, mouse.y);

					    if(mouse.y <0){
							theta = -theta;
					    }

					    if(arrowObj && bow){
							arrowObj.rotation.z = theta * 0.0174533;
							bow.rotation.z = theta * 0.0174533
					    }

					    v0 = computeVelInit(mass, effectController.lb, effectController.tension);
					    ft = flightTime(v0, theta);
					    rotationGravity = 2*theta*0.0174533 * 0.016666666667 / ft;
					}

				}	

				// Al click del mouse, se si è pronti a sparare, viene rilasciata la freccia
				function onDocumentMouseDown(event){
				    if (readyToFire) {
					released = true;
					controls.enabled = true;
				    }
				}
					
				window.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'mousedown', onDocumentMouseDown, false );

				// RENDETING LOOP
				function render(){

					requestAnimationFrame(render);
					stats.update();

					tempo = tempo + 0.0166;		//tempo aggiornato ogni frame
					
					//ciclo per l'animazione delle statue
					for (var i =0; i<arrStat.length; i++) {
						if(arrStat[i]) {
							q.copy(q1);
							arrStat[i].quaternion.copy(q.slerp(q2,tempo));
						}	
					}					
					
					//Creazione FARETRA: all'inizio del gioco l'arcere puo' sparare 3 freccie
					// una gia' incoccata, le altre 2 appoggiate sul carretto
					if(fakeArrow && empty){
						//se esiste la fakeArrow e la faretra è vuota
						for(var i = 0; i < arrowCount-1; i++){

							var spareArrow = fakeArrow.clone();

							spareArrow.position.set(-4.35, 0.5, 2.0 + i*0.2);
							spareArrow.rotation.z = -50 * Math.PI / 180;

							scene.add(spareArrow);
						}

						empty = false;

					}

					//Precaricamento delle statue in base a quanti mostri sono stati uccisi
					if(preload){
						loadStatues();
						preload =false;
					}

					// RENDERIZZA ANIMAZIONE INIZIALE
					if (!introOver && target) {
						target.position.x = effectController.target;
						targetCamera.lookAt(arrowContainer.position);


						if(targetCamera.position.x <= target.position.x + 20)
							targetCamera.position.x += 1.5;
						else
							introOver = true;

						renderer.render(scene, targetCamera);

					} 

					// RENDERIZZA IL GIOCO
					else {

						sceneControls.update();

						//Avanzamento del mostro verso il giocatore
						if(target && monster_death && monster_attack && !hitted && target.position.x > 1 && !missed){
							target.position.x = target.position.x - 0.08;
							monster_death.position.x = target.position.x;
							monster_attack.position.x = target.position.x;
							effectController.target = target.position.x;
						}

						//Riposizionamento del pivot in base alla posizione del target
						if(!readyToFire && target){
							pivot.position.x = effectController.target / 2;
						}

						//In base all'allungo impostato la freccia va indietro prima di essere rilasciata: questo per dare la sensazione di tensione dell'arco e maggiore forza applicata al proiettile
						var percenTns = effectController.tension * 100 / 0.6;
						if(fakeArrow){
							fakeArrow.position.x = -( percenTns / 100);
						}
						
						// Gestione telecamere
						// Aggiunta una quarta telecamera in caso il mostro venga colpito
						if(!hitted){

							if(keyboard.pressed("1") && released){
								mainActive = false;
								sceneActive = false;
							}
							if(keyboard.pressed("2")){
								mainActive = true;
								sceneActive = false;
							}
							if(keyboard.pressed("3")){
								mainActive = false;
								sceneActive = true;
							}

						} else {

							if(keyboard.pressed("1") && released){
								mainActive = false;
								sceneActive = false;
								releaseCam = true;
								fatal_mesh.visible = false;
							}
							if(keyboard.pressed("2")){
								mainActive = true;
								sceneActive = false;
								releaseCam = true;
								fatal_mesh.visible = false;
							}
							if(keyboard.pressed("3")){
								mainActive = false;
								sceneActive = true;
								releaseCam = true;
								fatal_mesh.visible = false;
							}
							if(keyboard.pressed("4")){  
								mainActive = false;
								sceneActive = false;
								releaseCam = false;
								fatal_mesh.visible = true;
							}

						}

						// Premendo Spazio la freccia viene sbloccata ed è pronta per essere sparata (premendo nuovamente si può bloccarla di nuovo)
						// Viene usato un semaforo per indicare all'utente se la freccia è pronta (VERDE) o meno (ROSSO)
						// Un timeout di 30 frame serve a prevenire lo spam del tasto
						if(keyboard.pressed("space") && timeOut == 0 && !slained){

							timeOut = 30;
							readyToFire = !readyToFire; 
							

							if(readyToFire){
								
								uniforms_normal.lightPower3.value = lightPowerGreen;
								uniforms_brick.lightPower3.value = lightPowerGreen;
								prat_uniforms.lightPower3.value = lightPowerGreen;
								arrow_uniforms.lightPower3.value = lightPowerGreen;
								bow_uniforms.lightPower3.value = lightPowerGreen;
								uniforms_cart.lightPower3.value = lightPowerGreen;
								lamp_uniforms.lightPower3.value = lightPowerGreen;
								column_uniforms.lightPower3.value = lightPowerGreen;

								uniforms_normal.lightPower2.value = NO_POWER;
								uniforms_brick.lightPower2.value = NO_POWER;
								prat_uniforms.lightPower2.value = NO_POWER;
								arrow_uniforms.lightPower2.value = NO_POWER;
								bow_uniforms.lightPower2.value = NO_POWER;
								uniforms_cart.lightPower2.value = NO_POWER;
								lamp_uniforms.lightPower2.value = NO_POWER;
								column_uniforms.lightPower2.value = NO_POWER;

								light2.visible = false;
								light3.visible = true;

							} else {

								uniforms_normal.lightPower2.value = lightPowerRed;
								uniforms_brick.lightPower2.value = lightPowerRed;
								prat_uniforms.lightPower2.value = lightPowerRed;
								arrow_uniforms.lightPower2.value = lightPowerRed;
								bow_uniforms.lightPower2.value = lightPowerRed;
								uniforms_cart.lightPower2.value = lightPowerRed;
								lamp_uniforms.lightPower2.value = lightPowerRed;
								column_uniforms.lightPower2.value = lightPowerRed;

								uniforms_normal.lightPower3.value = NO_POWER;
								uniforms_brick.lightPower3.value = NO_POWER;
								prat_uniforms.lightPower3.value = NO_POWER;
								arrow_uniforms.lightPower3.value = NO_POWER;
								bow_uniforms.lightPower3.value = NO_POWER;
								uniforms_cart.lightPower3.value = NO_POWER;
								lamp_uniforms.lightPower3.value = NO_POWER;
								column_uniforms.lightPower3.value = NO_POWER;

								light2.visible = true;
								light3.visible = false;
								
							}

						}

						// Il tasto E serve a re inizializzare la scena in modo da poter scagliare un'altra freccia
						// NOTA: Non è un refresh della pagina
						if(keyboard.pressed("E") && resetter){

							arrowCount--;

							if(arrowCount>0){
								empty = true;
								init();	
							}else {
								document.getElementById("scores").innerHTML += "<br>GAME OVER";
								document.getElementById("scores").innerHTML += "<br>Refresh the page to play more";
								resetter = false;

							}

							for(var i = 0; i<arrStat.length;i++){
								scene.remove(arrStat[i]);
							}
							preload = true;
							
						}


						// GAME LOGIC
						if(hitted && monster_death && arrowContainer && !releaseCam){
							// Se il mostro viene colpito, parte l'effetto di post Processing descritto in KillCamShader.js
							// Viene riprodotto un suono di morte del mostro 
							if(killCam.enabled) {

								// Urlo del mostro
								if(!playSound) {
									monster_death.add(monsterKillSound);
									monsterKillSound.play();
									playSound = true;
								}

								// Aggiunta di un testo mobile mediante Tween.js 
								if(!showFatality) {

									playFatality();
									tween.start();
									showFatality = true;

									statueCounter++;
					
								}

								// Update dell'animazione tween 
								if(tweenActive) {
									TWEEN.update();									
								}

								arrowContainer.remove(mainCamera);
								mainCamera.position.set(arrowContainer.position.x, 5, 5);
								mainCamera.lookAt(monster_death.position);
								
								// Modificando le uniform del killCamShader, aggiungiamo distrurbo alla scena e facciamo pulsare di rosso lo schermo (lentamente)
								if(killCam.uniforms.amount.value < 1.0 ){
									killCam.uniforms.amount.value += 0.01;
								} else {

									if(killCam.uniforms.index.value < 1.0 ){
										killCam.uniforms.index.value += 0.01;
									} else {
										color += 0.01;
										killCam.uniforms.color.value.y=0.0;
										killCam.uniforms.color.value.z=0.0;
										killCam.uniforms.color.value.x = Math.abs( Math.sin(color) )+ 0.35;
										if(killCam.uniforms.color.value.x > 0.7){
											killCam.uniforms.color.value.x = 0.7; //ecco
										}
									}

								}

							}

							killCam.uniforms.time.value = (killCam.uniforms.time.value + 0.2) % 10;
							composer.render();

						} else {

							// Vengono mantenute le tre camere principali
							if(mainActive){
								renderer.render(scene, mainCamera);
							} else {
								sceneActive ? renderer.render(scene, sceneCamera) : renderer.render(scene, arrowCamera);
							}

						}					
						

						// Riposizionamento della freccia per ogni frame
						if(arrowObj && arrowLoader ){
							
							y0=arrowContainer.position.y;
							x0=arrowContainer.position.x;
							cy0=arrowCamera.position.y;
							cx0=arrowCamera.position.x;

							y = y0;
							x = x0;
							cy = cy0;
							cx = cx0;
							arrowLoader = false;		
						}						
							
						// Quando il mostro si avvicina troppo al giocatore, lo attacca e uccide (la partita termina)
						if(target && target.position.x < 5.05 && !slained) {   

							target.visible = false;
							monster_attack.visible = true;	

							if(attackAnimation && trigger) {					
								monster_attack.rotation.y = Math.PI;
								attackAnimation.play();	

								trigger = false;
							}

							// Riproduzione suono di morte arcere
							if(!playSound) {
									killSound.play();
									playSound = true;
							}
						
							// Stampa informazioni su schermo
							if(enableWriting) {
								document.getElementById("scores").style.color = "red";
								document.getElementById("scores").innerHTML += "<br>You have been slained!";
								document.getElementById("scores").innerHTML += "<br>GAME OVER";
								document.getElementById("scores").innerHTML += "<br>Refresh the page to play more";
								enableWriting = false;
							}

							resetter = false;		// impossibile re inizializzare la scena una volta uccisi dal mostro
							slained = true;

						}

						// Lancio effettivo della freccia
						if(arrowObj && released){

							controls.update();
							arrowObj.visible = true;
							fakeArrow.visible = false;		// viene nascosta la freccia usata nella scelta dell'angolazione del tiro 

						    if( y>=0 && !hitted){

						    	// Bounding volumes per implementare i colliders
								arrowBox.setFromObject(arrowObj);
								targetBox.setFromObject(target);

								// Controllo intersezione dei bounding volumes
								if(!arrowBox.isIntersectionBox(targetBox)){

								    x = computeXShot(x0, theta, v0, t);
								    y = computeYShot(y0, theta, v0, t);
								    t += 0.01667;

								    arrowObj.rotation.z -= rotationGravity;
								    arrowContainer.position.set(x, y, arrowContainer.position.z);

									if(count >= 60){
										cx = computeXShot(cx0, theta, v0, t2);
										cy = computeYShot(cy0, theta, v0, t2);
										t2+=0.01667;

										arrowCamera.position.set(cx, cy, arrowContainer.position.z);							
									}

									if(y<=0) {				// se la freccia ha toccato terra

										missed = true;
										arrowContainer.add(failSound);
										failSound.play();

										if(enableWriting) {
										   	document.getElementById("scores").innerHTML += "<br>Missed Target";
										   	document.getElementById("scores").innerHTML += "<br>Press E to shoot more";
										   	enableWriting = false;
										}

									   	resetter = true;

									}

									if(arrowContainer.position.x >= 150) {		// se la freccia è troppo lontana

									   	missed = true;
									    arrowContainer.remove(mainCamera);

									   	arrowContainer.add(failSound);
										failSound.play();

										if(enableWriting) {
										   	document.getElementById("scores").innerHTML += "<br>Arrow went too far away!!";
										   	document.getElementById("scores").innerHTML += "<br>Press E to shoot more";
										   	enableWriting = false;
										}

									   	resetter = true;
									}

								} else {

									x = computeXShot(x0, theta, v0, t);
								   	y = computeYShot(y0, theta, v0, t);
								  	t += 0.01667; 

									arrowContainer.position.set(x, y, arrowContainer.position.z);
									arrowObj.visible = false;
									arrowContainer.visible = false;
									hitted = true;

									if(monster_death && target){

											target.visible = false;
											monster_death.visible = true;

											if(deathAnimation && trigger) {				// animazione di morte del mostro
												monster_death.rotation.y = Math.PI;
												deathAnimation.play();	
												trigger = false;
												killCam.enabled = true;
											}
										
									}

									// Punteggio assegnato al tiro
									if (y <= 1.3 && y >= 1.0)
										scoredPoints += 100;
									else
										scoredPoints += Math.floor(100 - 70 * Math.abs(1.15 - y));
									
									if(enableWriting) {
										document.getElementById("scores").innerHTML = "score: " + scoredPoints.toString(); //+ scoredPoints
										document.getElementById("scores").innerHTML += "<br>Good Job!";
										document.getElementById("scores").innerHTML += "<br>Press E to shoot more";
										enableWriting = false;
									}
									resetter = true;

								}

							}

						}

						count++;			// il calcolo della traiettoria del colpo viene eseguito ogni 60 frame
						if (timeOut > 0)	// timeout per evitare spam di un tasto
							timeOut--;

					}

					THREE.AnimationHandler.update( clock.getDelta() );		// animation handler del mostro			
				
				}

				init();
				render();
			</script>
		</div>
	</body>
</html>