<!DOCTYPE html>
<html>
<head>
	<title>Project Bowman</title>
	<style>canvas{width: 100%; height: 100%}</style>
</head>
<body>

<script src="lib/three.min.js"></script>
<script src="lib/stats.min.js"></script>
<script src="lib/OBJLoader.js"></script> 
<script src="lib/dat.gui.min.js"></script>
<script src="lib/threex.keyboardstate.js"></script> 
<script type="text/javascript" src="lib/OrbitControls.js"></script>
<script src="assets/scripts/physics.js"></script>
<script src="assets/scripts/Utils.js"></script>

<script>

	//DICHIARAZIONE DI TUTTE LE VARIABILI GLOBALI IN GIOCO

	var scene, mainCamera, arrowCamera;
	var controls;
	var mouse, keyboard;
	var hitted, arrowLoader, mainActive, readyToFire, released;
	var y0, x0, x, y;
	var cy0, cx0, cx, cy;
	var ft, rotationGravity, v0, theta, mass, t, t2;
	var floor, floorMaterial, floorGeometry;
	var underGround, underMaterial, underGeometry;
	var sky, skyMaterial, skyGeometry;
	var standardMaterial, bow, loader, arrowContainer, arrowObj, arrowBox, fakeArrow, archer, target, targetBox;
	var arrowObj = null;
	var fakeArrow = null;
	var count;

	//INIZIALIZZAZIONE DEL RENDERER, DEGLI STATS E DELLA DAT.GUI

	var renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0xffffff, 1);
	document.body.appendChild(renderer.domElement);

	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	document.body.appendChild( stats.domElement );

	// DAT GUI CREATION
	var gui = new dat.GUI( { height: 4 * 32 - 1 } );
	var effectController = { tension: 0.2, lb: 50, shoot: function() { readyToFire = true; 
		fakeArrow.traverse(function (child) {
		    if (child instanceof THREE.Mesh) {
		    child.material  =  new THREE.MeshBasicMaterial({color: 0x00ff00});
		    }
		}) }, target: 100 , reset: function(){init()}};
	gui.add(effectController, 'tension', 0.2, 0.6).name('Allungo').step(0.1);
	gui.add(effectController, 'lb', 20, 70).name('Libraggio arco').step(5);
	gui.add(effectController, 'target', 30, 500).step(10).name('Target');
	gui.add(effectController, 'shoot').name('Pronto al tiro');
	gui.add(effectController, 'reset').name('Reset');

	//FUNZIONE INIT CHE DA IL VIA ALLA CREAZIONE DI UNA NUOVA SCENA

	function init(){

		scene = new THREE.Scene();
		mainCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		arrowCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

		controls = new THREE.OrbitControls( mainCamera, renderer.domElement );
		controls.enabled = false;

		mouse = new THREE.Vector2();
		keyboard = new THREEx.KeyboardState();

		hitted = false;					//variabile booleana che controlla se il targer viene centrato
		mainActive = true;				//telecamera principale abilitata/disabilitata
		readyToFire = false;			//freccia pronta ad essere scoccata
		arrowLoader = true;				//variabile che gestisce il calcolo della posizione iniziale della freccia (da fare una sola volta)
		released = false;				//freccia scoccata

		//INIZIALIZZAZIONE DELLE VARIABILI USATE NEI CALCOLI DELLA FISICA DEL PROIETTILE

		theta = 0; 						//theta Ã¨ in gradi
		mass = 0.025;					//massa della freccia in kg
		t = 0;							//tempo
		t2 = 0;							//tempo (arrowCamera)

		count = 0;						//contatore ausiliario

		mainCamera.position.set(0, 0, 5);
		arrowCamera.position.set(-2, 1, 0);
		scene.add(arrowCamera);

		// FLOOR
		floorMaterial = new THREE.MeshBasicMaterial( { color: 0x028D27, side: THREE.DoubleSide } );
		floorGeometry = new THREE.CircleGeometry(2000, 200);
		floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -0.3;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);	

		// UNDERGROUND
		underMaterial = new THREE.MeshBasicMaterial( {color: 0x493000,  side: THREE.BackSide} );
		underGeometry = new THREE.SphereGeometry( 900, 200, 200, 0, Math.PI);
		underGround = new THREE.Mesh(underGeometry, underMaterial);
		underGround.position.y = -0.3;
		underGround.rotation.x = Math.PI / 2;
		scene.add(underGround);

		// SKY
		skyMaterial = new THREE.MeshBasicMaterial( {color: 0x77FFFC, side: THREE.BackSide } );
		skyGeometry = new THREE.SphereGeometry( 900, 200, 200, 0, Math.PI);
		sky = new THREE.Mesh(skyGeometry, skyMaterial);
		sky.position.y = -0.3;
		sky.rotation.x = -Math.PI / 2;
		scene.add(sky);

		arrowObj = null;
		fakeArrow = null;

		//LOADING BOW MESH
		standardMaterial = new THREE.MeshBasicMaterial();
		bow = new THREE.Object3D();
		loader = new THREE.OBJLoader();
		loader.load( 'assets/models/Bow.obj', function(object) { 
			object.material = standardMaterial;
			bow.add(object);
			} );
		bow.position.set(0,1,0);
		scene.add(bow);

		//CREATING ARROW CONTAINER
		arrowContainer = new THREE.Object3D();
		scene.add(arrowContainer);
		arrowContainer.position.set(0, 1, 0);
		arrowContainer.add(mainCamera);

		//CREATING ARCHER CONTAINER
		archer = new THREE.Object3D();
				archer.add(bow);
				archer.add(arrowContainer);
				scene.add(archer);

		//ARROW COLLISION BOX
		arrowBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );
		
		//LOADING ARROW MESH
		loader = new THREE.OBJLoader( );
		loader.load( 'assets/models/Arrow.obj', function ( object ) {
			object.traverse(function (child) {
			    if (child instanceof THREE.Mesh) {
			    child.material = new THREE.MeshBasicMaterial({color: 0x00ff00});;
			    }
			});
			arrowObj = object;
			arrowContainer.add(arrowObj);
			arrowObj.visible = false;
			fakeArrow = arrowObj.clone();
			fakeArrow.traverse(function (child) {
			    if (child instanceof THREE.Mesh) {
			    child.material = new THREE.MeshBasicMaterial({color: 0xff0000});;
			    }
			});
			fakeArrow.visible = true;
			bow.add(fakeArrow);
		
			arrowCamera.lookAt(arrowContainer.position);
		} );

		//LOADING TARGET MESH
		target = new THREE.Object3D();
		loader.load('assets/models/Target.obj', function (object ) {

			object.traverse(function (child) {
			    if (child instanceof THREE.Mesh) {
			    child.material = new THREE.MeshBasicMaterial({color: 0x0000ff});
			    }
			});

			target.add(object);
			});

		target.rotation.y = 90 * Math.PI / 180;	
		scene.add(target);

		// TARGET COLLISION BOX
		targetBox = new THREE.Box3( new THREE.Vector3(), new THREE.Vector3() );

	}


	function onMouseMove( event ) {
		
		if(!released && mainActive){
		    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;	

		    theta = getAngle(0, 0, mouse.x, mouse.y);

		    if(mouse.y <0){
				theta = -theta;
		    }

		    if(arrowObj && bow){
				arrowObj.rotation.z = theta * 0.0174533;
				bow.rotation.z = theta * 0.0174533
		    }

		    v0 = computeVelInit(mass, effectController.lb, effectController.tension);
		    ft = flightTime(v0, theta);
		    rotationGravity = 2*theta*0.0174533 * 0.016666666667 / ft;
		}

	}	
	
	function onDocumentMouseDown(event){
	    if (readyToFire) {
		released = true;
		controls.enabled = true;
	    }
	}
		

	window.addEventListener( 'mousemove', onMouseMove, false );
	window.addEventListener( 'mousedown', onDocumentMouseDown, false );

	function render(){
		requestAnimationFrame(render);
		
		stats.update();

		target.position.x = effectController.target;  // target posizionato dall'utente
		var percenTns = effectController.tension * 100 / 0.6;
		if(fakeArrow){
			fakeArrow.position.x = -( percenTns / 100);
		}
		

		if(keyboard.pressed("1") && released){
			mainActive = false;
		}
		if(keyboard.pressed("2")){
			mainActive = true;
		}
	
		if(mainActive){
			renderer.render(scene, mainCamera);
		} else {
			renderer.render(scene, arrowCamera);
		}
		
		//tempo = 1/60 secondi = 0.016666666667
		if(arrowObj && arrowLoader){
			y0=arrowContainer.position.y;
			x0=arrowContainer.position.x;
			cy0=arrowCamera.position.y;
			cx0=arrowCamera.position.x;

			y = y0;
			x = x0;
			cy = cy0;
			cx = cx0;
			arrowLoader = false;		
		}

		if(arrowObj && released){

			controls.update();
			arrowObj.visible = true;
			fakeArrow.visible = false;

		    if( y>=0 && !hitted){

				arrowBox.setFromObject(arrowObj);
				targetBox.setFromObject(target);

				if(!arrowBox.isIntersectionBox(targetBox)){

				    x = computeXShot(x0, theta, v0, t);
				    y = computeYShot(y0, theta, v0, t);
				    t+=0.01667;

				    arrowObj.rotation.z -= rotationGravity;
				    arrowContainer.position.set(x, y, arrowContainer.position.z);

					if(count >= 60){
						cx = computeXShot(cx0, theta, v0, t2);
						cy = computeYShot(cy0, theta, v0, t2);
						t2+=0.01667;

						arrowCamera.position.set(cx, cy, arrowContainer.position.z);
						sky.position.x = arrowContainer.position.x;
						underGround.position.x = arrowContainer.position.x;
					    }

				} else {

					x = computeXShot(x0, theta, v0, t);
				    y = computeYShot(y0, theta, v0, t);
				    t+=0.01667; 

					arrowContainer.position.set(x, y, arrowContainer.position.z);
					hitted = true;
				}
			}

		}
		count++;
	}

	init();
	render();
</script>

</body>
</html>
